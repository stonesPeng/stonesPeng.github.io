<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[复杂度分析（空间复杂度）（二）]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%89%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[（二）复杂度分析（空间复杂度）空间复杂度全称是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。 12345678void fuction(n)&#123; int i = 0; int[] a = new int[n]; for(i;i&lt;n;i++)&#123; a[i] = i*i; &#125; //use a[i] to do someting&#125; 例如上面的代码，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。 我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。 总结复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。等你学完整个专栏之后，你就会发现几乎所有的数据结构和算法的复杂度都跑不出这几个。 其它重要概念 最好情况时间复杂度（best case time complexity） 最坏情况时间复杂度（worst case time complexity） 平均情况时间复杂度（average case time complexity） 均摊时间复杂度（amortized time complexity）]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复杂度分析（时间复杂度）（一）]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%89%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[复杂度–时间复杂度 数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更加节省空间。 1.复杂度分析的必要性如果不采用事前的复杂度预估分析，只有采取事后的统计法。事后统计即把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。 但事后统计有非常大的局限性： 测试结果非常依赖环境（没有统一的标准） 测试结果受数据规模，结构的影响很大（例如不同排序算法） 2.大O复杂度表示法 T(n)表示代码执行的时间，n表示数据规模大小,f(n)表示每行代码执行次数的总和。从上图公式可看出，代码的执行时间T(n)与f(n)表达式成正比。 大O时间复杂度实际上并不表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。 而当n很大时候，公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可忽略，我们只需要记录一个最大量级就可以了。例如T(n) = O(n)； T(n) = O(n²) 3.时间复杂度分析方法 只关注循环执行次数最多的一段代码 加法法则：总复杂度等于量级最大的那段代码的复杂度 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 4.几种常见时间复杂度实例分析 复杂度量级可粗略的分为：多项式量级和非多项式量级。 我们把时间复杂度为非多项式量级的算法问题叫作NP（Non-Deterministic Polynomial，非确定多项式）问题，非多项式量级只有两个： O(2n) O(n!) 总的来说：当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。 5.常见的多项式时间复杂度1. O(1) 首先你必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。 123int i = 8;int j = 6;int sum = i + j; 我稍微总结一下，只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。 2. O(logn)、O(nlogn) 对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。我通过一个例子来说明一下。 1234i=1;while (i &lt;= n) &#123; i = i * 2;&#125; 根据我们前面讲的复杂度分析方法，第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。 从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的： 所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。通过 2x=n 求解 x 这个问题我们想高中应该就学过了，我就不多说了。x=log2n，所以，这段代码的时间复杂度就是 O(log2n)。 现在，我把代码稍微改下，你再看看，这段代码的时间复杂度是多少？ 1234i=1;while (i &lt;= n) &#123; i = i * 3;&#125; 根据我刚刚讲的思路，很简单就能看出来，这段代码的时间复杂度为 O(log3n)。 实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。为什么呢？ 我们知道，对数之间是可以互相转换的，log3n 就等于 log32 log2n，所以 O(log3n) = O(C log2n)，其中 C=log32 是一个常量。基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。所以，O(log2n) 就等于 O(log3n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。 如果你理解了我前面讲的 O(logn)，那 O(nlogn) 就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。 3. O(m+n)、O(m*n) 我们再来讲一种跟前面都不一样的时间复杂度，代码的复杂度由两个数据的规模来决定。老规矩，先看代码！ 123456789101112131415int cal(int m, int n) &#123; int sum_1 = 0; int i = 1; for (; i &lt; m; ++i) &#123; sum_1 = sum_1 + i; &#125; int sum_2 = 0; int j = 1; for (; j &lt; n; ++j) &#123; sum_2 = sum_2 + j; &#125; return sum_1 + sum_2;&#125; 从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。 针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)T2(n) = O(f(m) f(n))。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Filter Diff Interceptor]]></title>
    <url>%2F2019%2F03%2F15%2FFilter-Diff-Interceptor%2F</url>
    <content type="text"><![CDATA[Filter Diff InterceptorReference StackOverflow: HandlerInterceptor is basically similar to a Servlet Filter, but in contrast to the latter it just allows custom pre-processing with the option of prohibiting the execution of the handler itself, and custom post-processing. Filters are more powerful, for example they allow for exchanging the request and response objects that are handed down the chain. Note that a filter gets configured in web.xml, a HandlerInterceptor in the application context. As a basic guideline, fine-grained handler-related preprocessing tasks are candidates for HandlerInterceptor implementations, especially factored-out common handler code and authorization checks. On the other hand, a Filter is well-suited for request content and view content handling, like multipart forms and GZIP compression. This typically shows when one needs to map the filter to certain content types (e.g. images), or to all requests. 1. Filter Filter是servlet规范中定义的java web组件, 在所有支持java web的容器中都可以使用 Filter和Filter Chain是密不可分的, Filter可以实现依次调用正是因为有了Filter Chain Filter 调用链 上图是Filter对请求进行拦截的原理图 2.Interceptor Interceptor不是servlet规范中的java web组件, 而是Spring提供的组件 Interceptor功能的实现主要是在Spring Mvc的DispatcherServelt.doDispatch方法中 拦截器流程 调用拦截器的前置方法 -&gt; 调用处理请求的方法 -&gt; 渲染模版 -&gt; 调用拦截器的后置处理方法 -&gt; 调用拦截器的完成方法 3.Summary 从以上分析可以看到过滤器和拦截器实现的方式的不同. Filter是利用了方法的调用(入栈出栈)完成整个流程, 而Interceptor是利用了for循环完成了整个流程. Filter的实现比较占用栈空间, 在Filter多的情况下可能会有栈溢出的风险存在. Interceptor的实现逻辑更加的清晰简单 Filter组件更加的通用, 只要支持java servlet的容器都可以使用, 而Interceptor必须依赖于Spring Filter的优先级是高于Interceptor, 即请求是先到Filter再到Interceptor的, 因为Interceptor的实现主体还是一个servlet]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是SSL？]]></title>
    <url>%2F2019%2F03%2F13%2F%E4%BB%80%E4%B9%88%E6%98%AFSSL%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[SSL （安全套接字层） SSL是用在Web服务器和浏览器之间建立加密链接的标准安全技术，可确保在Web服务器和浏览器之间传递的所有数据保持私有和完整。SSL是行业标准，数千万的网站使用SSL来保护与客户的在线交易。 1.申请SSL证书 为了能够创建SSL连接，Web服务器需要SSL证书。当您选择在Web服务器上激活SSL时，系统将提示您完成有关您的网站和公司身份的许多问题。然后，您的Web服务器将创建两个加密密钥 - 私钥和公钥 公钥不需要保密，并放入证书签名请求（CSR） - 一个包含您的详细信息的数据文件。然后，您应该提交CSR。在SSL证书申请过程中，证书颁发机构将验证您的详细信息并颁发包含您的详细信息的SSL证书，并允许您使用SSL ​ 公钥证书 2.使用SSL证书 浏览器发送SSL证书与web服务器的私钥相匹配，然后，您的Web服务器将能够在网站和客户的Web浏览器之间建立加密链接 SSL协议的复杂性对您的客户来说仍然是不可见的。相反，他们的浏览器为他们提供了一个关键指示器，让他们知道他们当前受到SSL加密会话的保护 - 右下角的锁定图标，点击锁定图标会显示您的SSL证书及其详细信息。所有SSL证书均颁发给公司或法律责任人 3.总结 通常，SSL证书将包含您的域名，公司名称，地址，城市，州和国家/地区。它还将包含证书的到期日期以及负责颁发证书的证书颁发机构的详细信息 当浏览器连接到安全站点时，它将检索站点的SSL证书并检查它是否已过期，它是由浏览器信任的证书颁发机构颁发的，并且它已由发布它的网站使用 如果在这些检查中的任何一个检查失败，浏览器将向最终用户显示警告，告知他们该网站不受SSL保护]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>安全技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处方外流]]></title>
    <url>%2F2019%2F03%2F12%2F%E5%A4%84%E6%96%B9%E5%A4%96%E6%B5%81%2F</url>
    <content type="text"><![CDATA[处方外流 1. DTP（Direct to Patient）药品直接到达患者 即高值药品直送，由药企直接将高值药品配送到相关零售门店进行销售，省去代理商，商业利润更高。患者在拿到医院处方后可以在药房买到药物并获得专业的用药指导 DTP模式更依赖与药企的资源对接，以及更高的药事服务能力。其产品主要以高毛利的专业药、新特药为主，且多属于自费药品 DTP药房突出企业：上海医药（收购康德乐）、国大药房、老百姓大药房等2.药房托管（类似于学校的食堂外包） 医疗机构把药房经营权外包给有资质的企业经营，收取经营企业有偿经营和管理费用。是一种明晰药房所有者与经营者之间权力义务关系的以中药品经营模式特点是以医院为主导，医药流通企业承办居多，属于过度模式 由于未能完全破除医院和托管药房之间的利益关系，且存在托管费用过高等问题，目前托管药房模式正遭遇尴尬境地，行业非议之声不绝。3.院边店 由于其处于医院附近，地理位置优势将享受处方外流的红利4.互联网+医药新零售（医药O2O模式）（卖的更多，买的更好） 特点是满足患者购药的便捷性，药品品类比较单一，集中于非处方药和健康产品，处方来源是最重要的限制因素 目的：利用新技术充分挖掘用户的消费潜力、或为用户提供更细致周到的商品和服务 实现方式：大数据驱动、智能化、线上线下结合、供应链改造、用户体验升级 企业：阿里健康O2O联盟、京东到家、好药师、叮当快药、快方送药、生鲜外卖平台5.药店+诊所模式（类似于中医坐堂+药店模式） 药店内设诊所，提供基础医疗服务和慢病续方在互联网医疗发展起来之后，形成了远程诊疗+药店的模式，包括微医药诊店、微问诊等，其充分利用了医疗资源，为居民提供了轻问诊和电子处方6.院外处方流转平台 第三方公司搭建平台，连接医疗结构和药房，提供信息化、患者管理、数据管理等服务 总结 零售药店尤其是连锁零售药店是处方外流的最大获益者零售药店拥有非常好的业务基础，能够有序承接患者对药品和药事服务的需求；国内零售药店覆盖率较高，可顺势成为居民购药的首选； 在信息化工具、处方流转平台等助力下，零售药店的竞争力正在得到加强，能够为居民提供更多样化、精准的医药和健康管理服务问题 门槛：处方来源、患者意愿、医保对接、服务能力、信息管理]]></content>
      <categories>
        <category>业务</category>
      </categories>
      <tags>
        <tag>医疗服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关系数据模型&对象模型驱动]]></title>
    <url>%2F2019%2F03%2F11%2F%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E9%A9%B1%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[数据关系模型和对象模型 数据驱动、模型驱动作为如今软件设计中两种不同的模型驱动方法，应该说各有各的优缺点以及适用的场合，不能就一概的去认为哪种必然就是更好的。 1.数据关系模型驱动 数据驱动采用的方式是根据对业务的分析建立数据模型来进行系统设计的一种方法，通过数据模型的建立来完成系统的实现，一般来说，在采取数据模型的系统中多采用的是前台直接和数据模型进行绑定的方式，这样在实现起来相对来讲会非常的快速。根据数据驱动的系统设计以及实现方式上来讲，数据驱动适合于数据型的应用系统的建设，而现在大部分的中小型应用系统很多就停留在这个层面上，在这类系统中数据驱动会显得特别的实用和好用，这类系统一个非常突出的共同点就是系统基本属于信息的录入、显示以及查询这样的一个过程，不存在复杂的数据业务逻辑处理。 2.对象模型驱动 ​ 模型驱动采用的方式根据对业务的分析建立业务对象模型来进行系统设计的一种方法，通过业务对象模型结合系统架构约束来进行系统的实现，一般来说，在采取模型驱动的系统中多采用N层的结构体系，前台显示一般和业务显示模型进行交互，而业务显示模型则通过业务对象模型进行交互来完成业务逻辑的处理，业务对象模型通过与持久对象模型进行业务持久的处理，在这样的情况下，势必增加了系统的复杂度，模型驱动适合与业务型应用系统的建设，这个在行业化的业务应用上显得比较突出，这类系统的共同点在于业务逻辑较为复杂而且多变，系统不仅仅是信息的录入、显示以及查询，更多的是对录入或显示的信息进行业务逻辑的处理。经过上面的简单介绍后，我觉得对于数据驱动和模型驱动都会有个大概的概念，只能说数据驱动和模型驱动各有优势，要结合系统需求来选择相应的驱动方式。 ​ 对于模型驱动个人有些观点，其实从模型驱动我们可以看出如果采用模型驱动面对一个数据型的应用系统时，最后产生的业务对象模型即退化为了数据模型，只是由于模型驱动通常采用的N层架构此时反而约束了此模型的快速实现，是否应该在模型驱动的N层架构中去考虑一种退化的业务对象模型的支持呢？觉得这点是值得思考的，如果支持的话应该说对于模型驱动非常有利或者说是模型驱动的一个补充，相当于对于模型驱动进行分类处理，有些时候架构不能太S，还是要根据系统建设的需求做出适当的调整。 3.总结 ​ 根据这样的观点，其实数据驱动也是模型驱动，只是它采用的是一种退化的业务对象模型的驱动，并同时进行架构层次的调整以适应系统的快速建设，但数据驱动对于复杂多变的业务逻辑系统来说毕竟难去满足了，主要是会在数据模型的建立以及业务逻辑的修改的方面。 ​ 综合这样的观点，还是更为倾向模型驱动，同时也认为，模型驱动的架构应该考虑对于退化的业务对象模型的支持。]]></content>
      <categories>
        <category>领域驱动设计</category>
      </categories>
      <tags>
        <tag>设计思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法--先导篇]]></title>
    <url>%2F2019%2F03%2F07%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%88%E5%AF%BC%E7%AF%87%2F</url>
    <content type="text"><![CDATA[数据结构与算法 大学学习的第二个重要的课程就是《数据结构与算法》，当时学下来云里雾里饶，也不知道有什么作用，只是把重要的概念记下来应付考试。工作以后发现除了面试考官经常问起来，更重要的时候工作上很多时候都能用上，用上合适的数据存储结构、作用于特定数据结构上算法后，在空间复杂度和时间复杂度上都有明显的效率提升。为了回顾数据结构与算法并加上印象，特开展专题记录。 1.什么是数据结构与算法? 广义上，也就是从课本上说，数据结构就是一组存储数据的结构,而算法能就是操作数据的一组方法。 狭义上，其实是针对著名的数据结构与算法。著名的意思即前人的智慧结晶，我们时常听到的堆，栈，二分查找，快速排序等都是著名的数据结构与算法。站在巨人的肩膀上，我们能有更卓越的成就。 2.数据结构与算法的关系 总的来说两者是相辅相成的，缺一不可。 数据结构是为算法服务的，算法要作用在特定的数据结构之上。 因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。 数据结构是静态的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构就是没用的。 3.学习两者的方向 掌握常用的数据结构和算法的特点（口诀） 重点是学习他们的： “ 来历 ” 、 “ 特点 ” 、 “ 适合解决什么问题 ” 和 “实际的应用场景 ” 。 数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、 Trie 树 算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法 能进行复杂度分析（心法） 效率和资源消耗的度量衡即复杂度分析是数据结构和算法学习的精髓 数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此，我们就需要一个考量效率和资源消耗的方法，这就是复杂度分析方法。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome Extension]]></title>
    <url>%2F2019%2F03%2F01%2FChrome-Extension%2F</url>
    <content type="text"><![CDATA[前言使用浏览器扩展程序可以使你的工作效率提高数倍不止，那么下面我就向大家分享一下我日常使用的扩展，可能大多数扩展大家都已经在使用了，不过也难免有一两个是你不知道的。 正文 以下排名并不分先后，请坚持看到最后，或许你会有惊喜。 1.谷歌访问助手本来想了一波广告词来吹它，但想到… 算了，别问，问就是好用。 注：装了这个就可以访问之后介绍的扩展链接了。 链接：http://www.ggfwzs.com/ 2. 新浪微博图床感谢新浪微博提供的免费图床（对外链无限制），以及吊炸天的 cdn 图片加速服务，从此妈妈再也不用担心我的图床不能用了，另外还支持在网页图片右键菜单中一键上传。 链接：https://chrome.google.com/webstore/detail/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/fdfdnfpdplfbbnemmmoklbfjbhecpnhf 3. AdBlock最受欢迎的 Chrome 扩展，拥有超过 6000 万用户！拦截网页上的广告。 链接：https://chrome.google.com/webstore/detail/adblock/gighmmpiobklfepjocnamgkkbiglidom 4. WEB 前端助手前端神器，包括 JSON 格式化、二维码生成与解码、信息编解码、代码压缩、美化、页面取色、Markdown与HTML互转、网页滚动截屏、正则表达式、时间转换工具、编码规范检测、页面性能检测、Ajax接口调试、密码生成器、JSON 比对工具、网页编码设置、便签笔记。 链接：https://chrome.google.com/webstore/detail/pkgccpejnmalmdinmhkkfafefagiiiad 5. JSON Viewer前面介绍的 WEB 前端工具也有 JSON 查看工具，但是它那个太丑了，所以我用这个，内置多种主题，是我见过最好看的 JSON 查看工具。 链接：https://chrome.google.com/webstore/detail/json-viewer/gbmdgpbipfallnflgajpaliibnhdgobh 6. Standardized Screenshot一个非常好用的截图扩展，自动加上 macOS 的标题栏、以及阴影，配合微博图床一键上传根本不用保存在本地。 链接：https://chrome.google.com/webstore/detail/pabdhaakclnechgfhmnhkcbmjobeoope 7. Chromoji - Emoji在某些系统中并不能显示 Emoji 表情，安装此扩展后就能在浏览器中显示和输入，你也能选择显示 Apple 或 Google 风格的 Emoji。 链接：https://chrome.google.com/webstore/detail/chromoji-emoji-for-google/cahedbegdkagmcjfolhdlechbkeaieki 8. Clear Cache如果你是前端开发人员，调试时需要经常清空浏览器缓存，以往我们需要经过几个步骤才能完成动作，现在只需单击一下按钮即可清除缓存和浏览数据。 链接：Clear Cache 9. 二维码生成器把当前页面或者你输入的任何内容转化成二维码，生成后的二维码可以保存，并且无需联网，谁用谁知道。 链接：https://chrome.google.com/webstore/detail/quick-qr-code-generator/afpbjjgbdimpioenaedcjgkaigggcdpp?hl=zh-CN 10. 翻译侠这是我用了众多翻译扩展后最喜欢的一个，貌似之前的作者已经不再维护了，现在由网友接手，挺好的，从此不再需要打开谷歌翻译网站。 链接：https://chrome.google.com/webstore/detail/translate-man/fnjoonbenhhijnoegpfkpagjamomgjjm/related?hl=zh-CN 11. 图流这个厉害了，你是否曾为了看图片，一张一张的点，看完一个系列手都费了，简直痛不欲生，现在，福音来了。 让我们打开知乎问题《平常人可以漂亮到什么程度？》，查看全部答案，开启图流，你会发现。 另外它还支持轮播展示，如果你经常逛一些你懂得网站，那它简直是老司机神器。 链接：https://chrome.google.com/webstore/detail/%E5%9B%BE%E6%B5%81-%E7%9C%8B%E5%9B%BE%E5%8A%A9%E6%89%8B/gpcdnjdgomhddecjpknmfodkpkgibajh?utm_source=chrome-ntp-icon 12. 阅读模式提供与Safari阅读模式功能一致的插件，浏览文章页时候可进入友好的阅读模式，并自定义阅读功能。 唯一美中不足之处就是在阅读模式下无法选中文字（更不能使用划词翻译）。 链接：https://chrome.google.com/webstore/detail/reader-view/iibolhpkjjmoepndefdmdlmbpfhlgjpl 13. Octotree这个估计不少人知道，它可以在 GitHub 左侧显示当前项目的目录结构，能轻松找到代码的位置。 链接：https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc 14. Enhanced Github这个可以在 GitHub 中显示仓库大小，每个文件的大小，下载链接和复制文件内容的选项。 要是能够支持单文件夹下载那就更好了。 链接：https://chrome.google.com/webstore/detail/enhanced-github/anlikcnbgdeidpacdbdljnabclhahhmd 15. Isometric Contributions装X神器，值得拥有。这里放上我心中的偶像 Linus 的贡献图。 链接：https://chrome.google.com/webstore/detail/isometric-contributions/mjoedlfflcchnleknnceiplgaeoegien 16. Git History这个扩展可以很炫酷地展示 GitHub 中任意一个文件的历史修改情况。 链接：https://chrome.google.com/webstore/detail/git-history-browser-exten/laghnmifffncfonaoffcndocllegejnf 17. Tampermonkey油猴怕是没有人不知道，它基本上是所有扩展中的佼佼者了。这里给两个可以发现好用的脚本的网站： https://greasyfork.org/zh-CN https://openuserjs.org/ 链接：https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo 18. Stylus其实类似的扩展还有 Stylish，但它会窃取用户的浏览历史（虽然某位药王说我们更愿意用隐私换便利）。 而 Stylus 就不会。 链接：https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne ​ 转载来源：https://4ark.me//post/549a6198.html]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>browser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式汇总]]></title>
    <url>%2F2019%2F02%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[设计模式 设计模式代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式主要是基于面向对象的以下原则： 面向接口编程而不是实现 推崇对象组合而不是继承 1.设计模式分类共分为三大类 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 除以上三大类以外还有两类，即并发型模式和线程池模式。 2.设计模式六大原则总原则-开闭原则 对扩展开放，对修改封闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。即：为了使程序的扩展性好，易于维护和升级。 Ⅰ.单一职责原则（Single Responsibility Principle，简称SRP ） 核心思想：应该有且仅有一个原因引起类的变更 问题描述：假如有类Class1完成职责T1，T2，当职责T1或T2有变更需要修改时，有可能影响到该类的另外一个职责正常工作。 好处：类的复杂度降低、可读性提高、可维护性提高、扩展性提高、降低了变更引起的风险。 需注意：单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可以度量的，因项目和环境而异。 Ⅱ.里氏替换原则（Liskov Substitution Principle,简称LSP） 核心思想：在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类。 通俗来讲：只要父类能出现的地方子类就能出现。反之，父类则未必能胜任。 好处：增强程序的健壮性，即使增加了子类，原有的子类还可以继续运行。 需注意：如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系 采用依赖、聚合、组合等关系代替继承。 Ⅲ.依赖倒置原则（Dependence Inversion Principle,简称DIP） 核心思想：高层模块不应该依赖底层模块，二者都该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象； 说明：高层模块就是调用端，低层模块就是具体实现类。抽象就是指接口或抽象类。细节就是实现类。 通俗来讲：依赖倒置原则的本质就是通过抽象（接口或抽象类）使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合。 问题描述：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。 解决方案：将类A修改为依赖接口interface，类B和类C各自实现接口interface，类A通过接口interface间接与类B或者类C发生联系，则会大大降低修改类A的几率。 好处：依赖倒置的好处在小型项目中很难体现出来。但在大中型项目中可以减少需求变化引起的工作量。使并行开发更友好。 Ⅳ.接口隔离原则（Interface Segregation Principle,简称ISP） 核心思想：类间的依赖关系应该建立在最小的接口上 通俗来讲：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。 问题描述：类A通过接口interface依赖类B，类C通过接口interface依赖类D，如果接口interface对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。 需注意： 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情 为依赖接口的类定制服务。只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 Ⅴ.迪米特法则（Law of Demeter,简称LoD） 核心思想：类间解耦。 通俗来讲： 一个类对自己依赖的类知道的越少越好。自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。 Ⅵ.开放封闭原则（Open Close Principle,简称OCP） 核心思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化 通俗来讲： 一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。 总结 单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式[总]</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源协议详解]]></title>
    <url>%2F2019%2F02%2F25%2F%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[开源不等于免费！为了加速我们的开发，我们会使用开源的软件和源码； 为避免商业风险，需要在使用时了解第三方如软件协议，版本，和已知CVE风险等；本文旨在从开源软件再发布过程使用权限的角度入手，总结各个常见开源协议的异同，方便理解。 大部分人都希望作品能够被多数人分享查阅。这样不仅提高自己业界的知名度，同时也方便了需要的人为开源做出了贡献。但是代码一旦被贴出来，任何人都可以看到并获取，之后发生的事情你就无法控制了。 所以为了公开分享你的代码，同时又让你对代码保留一定权利，在作品中声明一个许可协议是非常有必要的。有协议和没声明协议的裸代码是有非常重要区别的，一般作品当中没声明协议的默认为Copy right的，也就是版权保留。此种情况表明他人没有任何授权，不得复制分发修改使用等等。有了协议的声明，在未来你的维权上面会方便很多，让你的作品在分享的同时保留了自身的一些权利。 License是软件的授权许可，里面详尽表述了你获得代码后拥有的权利，可以对别人的作品进行何种操作，何种操作又是被禁止的。 软件协议可分为开源和商业 对于商业协议，或者叫法律声明、许可协议，每个软件会有自己的一套行文，由软件作者或专门律师撰写。因为涉及到以后侵权打官司这种事情，这种商业条款的行文是非常严谨而讲究的，读起来很晦涩难懂。 对于开源协议，要知道开源不等于免费，也不等于没有约束。虽然相对商业协议要更加简明，但对于很多人来说还是像在看天书一样。 协议列表 首先一共有哪些公开的协议：https://opensource.org/licenses/alphabetical 常用协议 最流行的六种—-GPL、BSD、MIT、Mozilla、Apache和LGPL。 乌克兰程序员Paul Bagwell，画了一张分析图，说明应该怎么选择，只用两分钟，你就能搞清楚这六种许可证之间的最大区别。 下面是阮一峰中文翻译版本： 1. Apache 许可协议 Apache许可证(Apache License)，是一个在Apache软件基金会发布的自由软件许可证，最初为Apache http服务器而撰写。Apache许可证要求被授权者保留版权和放弃权利的申明，但它不是一个反版权的许可证。 此许可证最新版本为“版本2”，于2004年1月发布。 Apache许可证在Apache社区内外被广泛使用。Apache基金会下属所有项目都使用Apache许可证，许多非Apache基金会项目也使用了Apache许可证：据统计，截至2008年4月，在sourceforge上有超过3000个项目使用了Apache许可证。 Apache 许可协议, 2.0 版本, 授予了用户大量的权利。这些权利可以应用于拷贝权，也可以用于专利权。因为很多许可协议只能适用于拷贝权，不适用于专利权，所以这个灵活性就成了让有专利的开发者们选择许可协议时的一个显著参考因素 (要想明白两者之间的不同，请参考 How Stuff Works 上的这篇文章 )。 下面是关于 Apache 许可协议所允许的事项的详细说明： • 权利永恒。一旦被授权，权利永久不失。 • 权利无疆界。在一个国家里被授权，形同于在所有国家被授权。例如，你在美国，但许可权最初在印度被授予，你同样可以使用这个被授权的程序。 • 授权无需付费和支付酬劳。你既不需要在使用之前支付任何的费用，也无需在每次使用时支付任何的费用，或者其它类似情况。 • 权利不排他。使用这种许可协议下的软件时，不妨碍你使用其它软件。 • 权利不可变更。权利一旦授予，不可剥夺。也就是说，你在使用这个软件的过程中，你无需担心这种情况：当你开发出了令人羡慕的基于这种授权软件的衍生产品时，有人突然跳出来对你说，抱歉，你将不再被允许使用这个程序。 (在这个协议里有个条款声明：如果你控告别人在这个许可协议下的产品有侵犯专利的行为，那你的授权将会自动终止，但这只是适用于有专利权的作品。只要你不搞有专利作品的诉讼，你永远无需担心这种问题。) • 对再分发的作品还有个特殊要求，总的就是说要给予这些程序的作者和许可协议的维护者适当的名誉。 2. MIT 许可协议 MIT 协议应该是在流行的开源协议中最简短的、使用最广泛的一种协议。它的条款非常的宽松，而且跟其它协议相比更自由。 MIT 协议是目前最少限制的协议。 它基本上就是任何人可以对这个协议下的软件的做任何的事情，只要你能认可这个协议。这种协议最基本的条款 ( the information that it is provided without warranty, which comprises the final paragraph)如下： 特此授权，任何人都可免费获得这个软件以及相关文档（the Software）的拷贝，可以无限制的使用这个软件，包括无限制的权利去使用、复制、修改、合并、发布、附加从属协议，以及/或者出售软件的拷贝， 同时，为了让软件的提供者有权利做到这些，下面的条件必须遵守： 上面的拷贝权声明和许可声明必须包含在所有的这个软件拷贝里和实际分署部分里。 这也就是说： • 你可以随意使用，复制，修改这个软件。没有人能够阻止你在任何工程里使用它，你可以复制任意次数、以任何形式，或按你的愿望修改它。 • 你可以向外免费发放，或出售。你可以随意的分发它，没有任何限制。 • 唯一的限制是你必须接受协议条款。 3. BSD 许可协议 BSD 协议有很多分支，它们都代表了一种宽松的自由软件协议，相对其它协议，例如GPL，来说，它们对软件的传播给予了更少的限制。 在这种协议的各种版本中，有两个版本格外的重要： 新 BSD 协议/修订版 BSD 协议和简化 BSD 协议/FreeBSD 协议。这两类协议都实现的对 GPL 兼容的自由软件协议，而且被 Open Source Initiative 认可为开源软件协议。 新 BSD 协议(3-clause license)无任何限制的允许你以任何目的二次分发这种软件，唯一的要求是必须保留拷贝权的声明和协议里的软件权利放弃条款。这种协议还有一个限制，未经许可不得使用这个作品的所有曾经捐助者的署名。 新 BSD 协议和简化 BSD 协议的最主要的区别是后者删除了署名条款。 BSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”，可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。 但”为所欲为”的前提当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件： • 如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。 • 如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。 • 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。 • BSD 代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。 4. GPL许可协议 我们很熟悉的Linux就是采用了GPL。GPL协议和BSD， Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代 码做为闭源的商业软件发布和销售。 这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商 业软件公司开发的免费软件了。 GPL协议的主要内容是只要在一个软件中使用（”使用”指类库引用，修改后的代码或者衍生代码）GPL 协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。这就是所谓的”传染性”。GPL协议的产品作为一个单独的产品使用没有任何问题， 还可以享受免费的优势。 由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。 其它细节如再发布的时候需要伴随GPL协议等和BSD/Apache等类似。 5. LGPL许可协议 LGPL 是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL 允许商业软件通过类库引用（link）方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并 发布和销售。 但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因 此LGPL协议的开源 代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。 GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。 6. MPL许可协议 MPL是The Mozilla Public License的简写，是1998年初Netscape的 Mozilla小组为其开源软件项目设计的软件许可证。 MPL许可证出现的最重要原因就是，Netscape公司认为GPL许可证没有很好地平衡开发者对源代码的需求和他们利用源代码获得的利益。同著名的GPL许可证和BSD许可证相比，MPL在许多权利与义务的约定方面与它们相同（因为都是符合OSIA认定的开源软件许可证）。 但是，相比而言MPL还有以下几个显著的不同之处： - MPL虽然要求对于经MPL许可证发布的源代码的修改也要以MPL许可证的方式再许可出来，以保证其他人可以在MPL的条款下共享源代码。但是，在MPL许可证中对“发布”的定义是“以源代码方式发布的文件”，这就意味着MPL允许一个企业在自己已有的源代码库上加一个接口，除了接口程序的源代码以MPL许可证的形式对外许可外，源代码库中的源代码就可以不用MPL许可证的方式强制对外许可。这些，就为借鉴别人的源代码用做自己商业软件开发的行为留了一个豁口。 - MPL许可证第三条第7款中允许被许可人将经过MPL许可证获得的源代码同自己其他类型的代码混合得到自己的软件程序。 对软件专利的态度，MPL许可证不像GPL许可证那样明确表示反对软件专利，但是却明确要求源代码的提供者不能提供已经受专利保护的源代码（除非他本人是专利权人，并书面向公众免费许可这些源代码），也不能在将这些源代码以开放源代码许可证形式许可后再去申请与这些源代码有关的专利。 对源代码的定义 • 而在MPL（1.1版本）许可证中，对源代码的定义是:“源代码指的是对作品进行修改最优先择取的形式，它包括:所有模块的所有源程序，加上有关的接口的定义，加上控制可执行作品的安装和编译的‘原本’（原文为‘Script’），或者不是与初始源代码显著不同的源代码就是被源代码贡献者选择的从公共领域可以得到的程序代码。” • MPL许可证第3条有专门的一款是关于对源代码修改进行描述的规定，就是要求所有再发布者都得有一个专门的文件就对源代码程序修改的时间和修改的方式有描述。 小结 GPL协议、LGPL协议与BSD协议的法律区别。 简而言之，GPL协议就是一个开放源代码协议，软件的初始开发者使用了GPL协议并公开软件的源程序后，后续使用该软件源程序开发软件者亦应当根据GPL协议把自己编写的源程序进行公开。GPL协议要求的关键在于开放源程序，但并不排斥软件作者向用户收费。 虽然如此，很多大公司对GPL协议还是又爱又恨，爱的是这个协议项下的软件历经众多程序员千锤百炼的修改，已经非常成熟完善，恨的是必须开放自己后续的源程序，导致竞争对手也可以根据自己修改的源程序开发竞争产品。 正因大公司对GPL协议在商业上存在顾虑，因此，另两种协议被采用的更多，第一种是LGPL（亦称GPL V2）协议，可以翻译为更宽松的GPL协议。与GPL协议的区别为，后者如果只是对LGPL软件的程序库的程序进行调用而不是包含其源代码时，相关的源程序无需开源。 调用和包含的区别类似在互联网网网页上对他人网页内容的引用：如果把他人的内容全部或部分复制到自己的网页上，就类似包含，如果只是贴一个他人网页的网址链接而不引用内容，就类似调用。有了这个协议，很多大公司就可以把很多自己后续开发内容的源程序隐藏起来。 第二种是BSD协议（类似的还有MIT协议）。BSD协议鼓励软件的作者公开自己后续开发的源代码，但不强求。在BSD协议项下开发的软件，原始的源程序是开放源代码的，但使用者修改以后，可以自行选择发布源程序或者二进制程序（即目标程序），当然，使用者有义务把自己原来使用的源程序与BSD协议在软件对外发布时一并发布。因为比较灵活，所以BSD深受大公司的欢迎。]]></content>
      <categories>
        <category>扩展</category>
      </categories>
      <tags>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map--Usage]]></title>
    <url>%2F2019%2F01%2F31%2FMap%2F</url>
    <content type="text"><![CDATA[Map1. putIfAbsent和computeIfAbsent 都是在key不存在的时候才会建立key和value的映射关系；putIfAbset不论传入的value是否为空，都会建立映射（并不适合所有子类，例如HashTable），而computeIfAbsent方法，当存入value为空时，不做任何操作当key不存在时，返回的都是新的value（为什么不说新插入的value），即使computeIfAbsent在传入的value为null时，不会新建映射关系，但返回的也是null； 2. computeIfPresent和computeIfAbsent 这两个方法正好相反，前者是在key存在时，才会用新的value替换oldValue当传入的key存在，并且传入的value为null时，前者会remove（key），把传入的key对应的映射关系移除；而后者不论何时都不会remove()；前者只有在key存在，并且传入的value不为空的时候，返回值是value，其他情况都是返回null；后者只有在key不存在，并且传入的value不为null的时候才会返回value，其他情况都返回null； 3. compute 新传入的value不为null就建立映射关系（也就是说不论key是否为null，具体子类再具体分析）新传入的value为null时：key已存在，且老的对应value不为null，移除改映射关系，返回null；否则，直接返回null]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Drools--Group]]></title>
    <url>%2F2018%2F09%2F05%2FDrools%2F</url>
    <content type="text"><![CDATA[Drools-Group123456789101112131415/***具有相同activation-group属性的规则中只要有一个被执行，其他的规则都不再执行。*可以用类似salience之类的属性来实现规则的执行优先级*/activation-group/***将规则划分一个的组，然后在规则流当中通过使用ruleflow-group属性的值，从而使用*对应的规则，该属性会通过流程的走向确定要执行哪一条规则*/ruleflow-group/***Agenda Group 是用来在Agenda基础上对规则进行再次分组。引擎在调用设置了agenda-group*属性的规则时需要显示的指定某个agenda group 获得focus，否则将不执行此组的规则。*/agenda-group 1. Agenda-group 议程组允许将规则以组的形式，并将这么组放入堆栈，堆栈具有push/pop操作，通过SetFocus完成Push操作。1kieSession.getAgenda().getAgendaGroup("group2").setFocus(); 议程总是在栈顶执行，当议程组所有的规则执行后，这个议程组会被移除然后执行下一组。1234567891011121314151617181920212223242526public void excuteAgendaGroup()&#123; KieBase kieBase = KieStarter.newKieBase(getAgendaGroupDrl()); KieSession kieSession = kieBase.newKieSession(); //group2 后执行 kieSession.getAgenda().getAgendaGroup("group2").setFocus(); //group1 先执行 kieSession.getAgenda().getAgendaGroup("group1").setFocus(); kieSession.fireAllRules(); kieSession.dispose();&#125;private String getAgendaGroupDrl()&#123; return "rule \"test-agenda-group1\" " + "agenda-group \"group1\" " + "when then System.out.println(\"test-agenda-group1-1 被触发\"); " + "end " + "rule \"test-agenda-group2\" " + "agenda-group \"group2\" " + "when " + "then " + "System.out.println(\"test-agenda-group2 被触发\"); end\n" + "rule \"test-agenda-group3\" " + "agenda-group \"group1\" " + "when then System.out.println(\"test-agenda-group1-2 被触发\"); " + "end ";&#125; 2.Activation-Group 激活组要求相同组只执行一个123456789101112131415161718public void executeActivationGroup()&#123; KieBase kieBase = KieStarter.newKieBase(getActivationGroupDrl()); KieSession kieSession = kieBase.newKieSession(); kieSession.fireAllRules();&#125;private String getActivationGroupDrl()&#123; return "rule \"test-activation-group1\" " + "salience 1"+ "activation-group \"group1\" " + "when then System.out.println(\"test-activation-group1 被触发\"); " + "end " + "rule \"test-activation-group2\" " + "salience 2"+ "activation-group \"group1\" " + "when " + "then " + "System.out.println(\"test-activation-group2 被触发\"); end\n";&#125; 3. Flow-Group 流式组支持服务编排，像工作流一样先后顺序运行规则]]></content>
      <categories>
        <category>引擎</category>
      </categories>
      <tags>
        <tag>Drools</tag>
      </tags>
  </entry>
</search>
